(function(){
	const statusEl = document.getElementById('status');
	const lastUpdatedEl = document.getElementById('lastUpdated');
	const tableHead = document.getElementById('tableHead');
	const tableBody = document.getElementById('tableBody');

	// Dashboard elements
	const socGauge = document.getElementById('socGauge');
	const socValEl = document.getElementById('socVal');
	const socCcEl = document.getElementById('socCcVal');
	const socEkfEl = document.getElementById('socEkfVal');
	const socAiEl = document.getElementById('socAiVal');
	const voltValEl = document.getElementById('voltVal');
	const voltModelValEl = document.getElementById('voltModelVal');
	const voltRcEkfEl = document.getElementById('voltRcEkfVal');
	const currValEl = document.getElementById('currVal');
	const tempValEl = document.getElementById('tempVal');
	const stateValEl = document.getElementById('stateVal');
	const tsValEl = document.getElementById('tsVal');
	const voltSpark = document.getElementById('voltSpark');
	const currSpark = document.getElementById('currSpark');
	const tempSpark = document.getElementById('tempSpark');

	let pollTimer = null;
	let lastChecksum = '';

	// Settings
	const FIXED_RANGE = 'ICR186501!A1:J1000';
	const POLL_MS = 5000; // 5 seconds

	// Simple in-memory history for temperature sparkline
	const historyLimit = 90;
	const history = { voltage: [], current: [], temperature: [] };

	function setStatus(text, isError=false){
		statusEl.textContent = text;
		statusEl.style.color = isError ? '#b91c1c' : '#334155';
	}

	function setLastUpdated(){
		const now = new Date();
		lastUpdatedEl.textContent = `Last updated: ${now.toLocaleString()}`;
	}

	function renderTable(values){
		tableHead.innerHTML = '';
		tableBody.innerHTML = '';
		if(!values || values.length === 0){ setStatus('No data in the selected range.'); return; }
		const headerRow = document.createElement('tr');
		values[0].forEach(cell => { const th = document.createElement('th'); th.textContent = String(cell ?? ''); headerRow.appendChild(th); });
		tableHead.appendChild(headerRow);
		for(let r=1; r<values.length; r++){
			const tr = document.createElement('tr');
			values[r].forEach(cell => { const td = document.createElement('td'); td.textContent = String(cell ?? ''); tr.appendChild(td); });
			tableBody.appendChild(tr);
		}
	}

	function checksum(values){ try { return JSON.stringify(values); } catch(_){ return Math.random().toString(36); } }
	function normalizeHeader(h){ return String(h || '').toLowerCase().replace(/[^a-z0-9]+/g, ''); }
	function indicesFromHeaders(values){ const headers = values[0] || []; const norm = headers.map(normalizeHeader); return { idxTimestamp: norm.indexOf('timestamp'), idxSocCc: norm.indexOf('soccc'), idxSocEkf: norm.indexOf('socekf'), idxSocAi: norm.indexOf('socai'), idxStatus: norm.indexOf('status'), idxVMeas: norm.indexOf('vmeasv'), idxVModel: norm.indexOf('vmodelv'), idxIMeas: norm.indexOf('imeasa'), idxTemp: norm.indexOf('tempc'), idxVRcEkf: norm.indexOf('vrcekfv') }; }
	function parseLatest(values){ if(!values || values.length < 2) return null; const idx = indicesFromHeaders(values); let last = values.length - 1; while(last > 0 && (!values[last] || values[last].every(c => c === '' || c == null))) last--; const row = values[last] || []; const strAt = i => (i>=0 ? String(row[i] ?? '') : ''); const numAt = i => { const n = Number(strAt(i)); return Number.isFinite(n) ? n : undefined; }; return { timestamp: strAt(idx.idxTimestamp), socCc: numAt(idx.idxSocCc), socEkf: numAt(idx.idxSocEkf), socAi: numAt(idx.idxSocAi), status: strAt(idx.idxStatus), vMeas: numAt(idx.idxVMeas), vModel: numAt(idx.idxVModel), iMeas: numAt(idx.idxIMeas), temp: numAt(idx.idxTemp), vRcEkf: numAt(idx.idxVRcEkf) }; }
	function sliceLastNSeries(values, n){ if(!values || values.length < 2) return { vMeas: [], vModel: [], vRcEkf: [], current: [], timestamps: [] }; const idx = indicesFromHeaders(values); const vMeas = []; const vModel = []; const vRcEkf = []; const current = []; const timestamps = []; for(let r = Math.max(1, values.length - n); r < values.length; r++){ const row = values[r] || []; vMeas.push(idx.idxVMeas >= 0 ? Number(row[idx.idxVMeas]) : undefined); vModel.push(idx.idxVModel >= 0 ? Number(row[idx.idxVModel]) : undefined); vRcEkf.push(idx.idxVRcEkf >= 0 ? Number(row[idx.idxVRcEkf]) : undefined); current.push(idx.idxIMeas >= 0 ? Number(row[idx.idxIMeas]) : undefined); timestamps.push(idx.idxTimestamp >= 0 ? String(row[idx.idxTimestamp] || '') : ''); } return { vMeas, vModel, vRcEkf, current, timestamps }; }
	function applyStateColor(text){ const t = String(text || '').toLowerCase(); stateValEl && (stateValEl.className = ''); if(t.includes('discharg')) stateValEl && stateValEl.classList.add('state-discharging'); else if(t.includes('charg')) stateValEl && stateValEl.classList.add('state-charging'); else stateValEl && stateValEl.classList.add('state-idle'); }
	function drawSocGauge(canvas, percent, isDisconnected=false){ if(!canvas) return; const ctx = canvas.getContext('2d'); const w = canvas.width, h = canvas.height; ctx.clearRect(0,0,w,h); const cx = w/2, cy = h*0.9; const r = Math.min(w, h*1.6)/2; const start = Math.PI; const end = 2*Math.PI; ctx.lineWidth = 16; ctx.strokeStyle = '#e2e8f0'; ctx.beginPath(); ctx.arc(cx, cy, r, start, end); ctx.stroke(); if(isDisconnected){ ctx.strokeStyle = '#64748b'; ctx.lineWidth = 2; ctx.setLineDash([8, 4]); ctx.beginPath(); ctx.arc(cx, cy, r, start, end); ctx.stroke(); ctx.setLineDash([]); } else { const clamped = Math.max(0, Math.min(100, Number(percent)||0)); const frac = clamped/100; const valEnd = start + (end - start) * frac; ctx.strokeStyle = clamped > 60 ? '#16a34a' : (clamped > 20 ? '#f59e0b' : '#ef4444'); ctx.beginPath(); ctx.arc(cx, cy, r, start, valEnd); ctx.stroke(); } }
	function normalizeSeries(series){ return series.map(v => Number.isFinite(v) ? v : undefined); }
	function getMinMax(seriesList){ let mins=[]; let maxs=[]; for(const s of seriesList){ const vals = s.filter(v => typeof v === 'number'); if(vals.length){ mins.push(Math.min(...vals)); maxs.push(Math.max(...vals)); } } const min = mins.length ? Math.min(...mins) : 0; const max = maxs.length ? Math.max(...maxs) : 1; return { min, max: min===max ? min+1 : max }; }
	function xAt(w,pad,i,count){ if(count<=1) return pad; return pad + (w-2*pad)*(i/(count-1)); }
	function yAt(h,pad,value,min,span){ return h - pad - (h-2*pad)*((value-min)/span); }
	function drawVoltageChart(canvas, vMeas, vModel, vRcEkf, timestamps){ if(!canvas) return; const ctx = canvas.getContext('2d'); const w=canvas.width,h=canvas.height; ctx.clearRect(0,0,w,h); const leftPad=55,rightPad=15,topPad=35,bottomPad=50; const chartW=w-leftPad-rightPad,chartH=h-topPad-bottomPad; const s1=normalizeSeries(vMeas); const s2=normalizeSeries(vModel); const s3=normalizeSeries(vRcEkf); const {min,max}=getMinMax([s1,s2,s3]); const span=Math.max(1e-9,max-min); const yTicks=5; const x0=leftPad,y0=topPad,x1=leftPad+chartW,y1=topPad+chartH; ctx.fillStyle='#ffffff'; ctx.fillRect(x0-1,y0-1,chartW+2,chartH+2); ctx.strokeStyle='#e2e8f0'; ctx.lineWidth=1; for(let i=0;i<=yTicks;i++){ const val=min+(max-min)*(i/yTicks); const y=y0+chartH*(1-i/yTicks); ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke(); ctx.fillStyle='#64748b'; ctx.font='10px system-ui'; ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.fillText(val.toFixed(3),x0-8,y); } for(let i=0;i<s1.length;i++){ const x=x0+chartW*(i/(s1.length-1||1)); ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke(); if(timestamps[i]){ const timeStr=timestamps[i].length>8?timestamps[i].substring(11,19):timestamps[i]; ctx.fillStyle='#64748b'; ctx.font='9px system-ui'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.save(); ctx.translate(x,y1+5); ctx.rotate(-Math.PI/4); ctx.fillText(timeStr,0,0); ctx.restore(); } } ctx.strokeStyle='#cbd5e1'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.lineTo(x1,y1); ctx.stroke(); ctx.fillStyle='#334155'; ctx.font='11px system-ui'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.fillText('Voltage (V)',w/2,y1+25); ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.save(); ctx.translate(15,h/2); ctx.rotate(-Math.PI/2); ctx.fillText('Voltage (V)',0,0); ctx.restore(); const points=[]; for(let i=0;i<s1.length;i++){ const v=s1[i]; if(typeof v!=='number') continue; const x=x0+chartW*(i/(s1.length-1||1)); const y=y0+chartH*((max-v)/span); points.push({x,y,v}); } ctx.beginPath(); let started=false; for(const p of points){ if(!started){ctx.moveTo(p.x,p.y); started=true;} else {ctx.lineTo(p.x,p.y);} } if(started){ ctx.lineTo(points[points.length-1].x,y1); ctx.lineTo(points[0].x,y1); ctx.closePath(); const grad=ctx.createLinearGradient(0,y0,0,y1); grad.addColorStop(0,'rgba(14,165,233,0.2)'); grad.addColorStop(1,'rgba(14,165,233,0.02)'); ctx.fillStyle=grad; ctx.fill(); } ctx.beginPath(); ctx.strokeStyle='#0ea5e9'; ctx.lineWidth=3; started=false; for(const p of points){ if(!started){ctx.moveTo(p.x,p.y); started=true;} else {ctx.lineTo(p.x,p.y);} } ctx.stroke(); ctx.beginPath(); ctx.setLineDash([5,4]); ctx.strokeStyle='#64748b'; ctx.lineWidth=2; started=false; for(let i=0;i<s2.length;i++){ const v=s2[i]; if(typeof v!=='number') continue; const x=x0+chartW*(i/(s2.length-1||1)); const y=y0+chartH*((max-v)/span); if(!started){ctx.moveTo(x,y); started=true;} else {ctx.lineTo(x,y);} } ctx.stroke(); ctx.beginPath(); ctx.setLineDash([3,3]); ctx.strokeStyle='#8b5cf6'; ctx.lineWidth=2; started=false; for(let i=0;i<s3.length;i++){ const v=s3[i]; if(typeof v!=='number') continue; const x=x0+chartW*(i/(s3.length-1||1)); const y=y0+chartH*((max-v)/span); if(!started){ctx.moveTo(x,y); started=true;} else {ctx.lineTo(x,y);} } ctx.stroke(); ctx.setLineDash([]); for(const p of points){ ctx.fillStyle='#0ea5e9'; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#ffffff'; ctx.lineWidth=2.5; ctx.stroke(); } ctx.font='10px system-ui'; ctx.fillStyle='#334155'; ctx.textAlign='left'; ctx.textBaseline='top'; ctx.fillText('V_meas',x0+5,5); ctx.fillStyle='#64748b'; ctx.setLineDash([5,4]); ctx.beginPath(); ctx.moveTo(x0+45,12); ctx.lineTo(x0+75,12); ctx.stroke(); ctx.setLineDash([]); ctx.fillText('V_model',x0+80,5); ctx.fillStyle='#8b5cf6'; ctx.setLineDash([3,3]); ctx.beginPath(); ctx.moveTo(x0+130,12); ctx.lineTo(x0+160,12); ctx.stroke(); ctx.setLineDash([]); ctx.fillText('V_RC_EKF',x0+165,5); }
	function drawCurrentChart(canvas, curr, timestamps){ if(!canvas) return; const ctx = canvas.getContext('2d'); const w=canvas.width,h=canvas.height; ctx.clearRect(0,0,w,h); const leftPad=55,rightPad=15,topPad=35,bottomPad=50; const chartW=w-leftPad-rightPad,chartH=h-topPad-bottomPad; const s=normalizeSeries(curr); const {min,max}=getMinMax([s]); const span=Math.max(1e-9,max-min); const yTicks=5; const x0=leftPad,y0=topPad,x1=leftPad+chartW,y1=topPad+chartH; ctx.fillStyle='#ffffff'; ctx.fillRect(x0-1,y0-1,chartW+2,chartH+2); ctx.strokeStyle='#e2e8f0'; ctx.lineWidth=1; for(let i=0;i<=yTicks;i++){ const val=min+(max-min)*(i/yTicks); const y=y0+chartH*(1-i/yTicks); ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke(); ctx.fillStyle='#64748b'; ctx.font='10px system-ui'; ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.fillText(val.toFixed(3),x0-8,y); } for(let i=0;i<s.length;i++){ const x=x0+chartW*(i/(s.length-1||1)); ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke(); if(timestamps[i]){ const timeStr=timestamps[i].length>8?timestamps[i].substring(11,19):timestamps[i]; ctx.fillStyle='#64748b'; ctx.font='9px system-ui'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.save(); ctx.translate(x,y1+5); ctx.rotate(-Math.PI/4); ctx.fillText(timeStr,0,0); ctx.restore(); } } ctx.strokeStyle='#cbd5e1'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.lineTo(x1,y1); ctx.stroke(); ctx.fillStyle='#334155'; ctx.font='11px system-ui'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.fillText('Time',w/2,y1+25); ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.save(); ctx.translate(15,h/2); ctx.rotate(-Math.PI/2); ctx.fillText('Current (A)',0,0); ctx.restore(); const points=[]; for(let i=0;i<s.length;i++){ const v=s[i]; if(typeof v!=='number') continue; const x=x0+chartW*(i/(s.length-1||1)); const y=y0+chartH*((max-v)/span); points.push({x,y,v}); } ctx.beginPath(); let started=false; for(const p of points){ if(!started){ctx.moveTo(p.x,p.y); started=true;} else {ctx.lineTo(p.x,p.y);} } if(started){ ctx.lineTo(points[points.length-1].x,y1); ctx.lineTo(points[0].x,y1); ctx.closePath(); const grad=ctx.createLinearGradient(0,y0,0,y1); grad.addColorStop(0,'rgba(16,185,129,0.2)'); grad.addColorStop(1,'rgba(16,185,129,0.02)'); ctx.fillStyle=grad; ctx.fill(); } ctx.beginPath(); ctx.strokeStyle='#10b981'; ctx.lineWidth=3; started=false; for(const p of points){ if(!started){ctx.moveTo(p.x,p.y); started=true;} else {ctx.lineTo(p.x,p.y);} } ctx.stroke(); for(const p of points){ ctx.fillStyle='#10b981'; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#ffffff'; ctx.lineWidth=2.5; ctx.stroke(); } }
	function drawSparkline(canvas, data, color){ if(!canvas) return; const ctx=canvas.getContext('2d'); const w=canvas.width,h=canvas.height; ctx.clearRect(0,0,w,h); const vals=(data||[]).filter(v=>typeof v==='number'); if(vals.length<2) return; const min=Math.min(...vals); const max=Math.max(...vals); const pad=4; const span=Math.max(1e-9,max-min); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); let first=true; for(let i=0;i<data.length;i++){ const v=data[i]; if(typeof v!=='number') continue; const x=pad+(w-2*pad)*(i/(data.length-1)); const y=h-pad-(h-2*pad)*((v-min)/span); if(first){ctx.moveTo(x,y); first=false;} else {ctx.lineTo(x,y);} } ctx.stroke(); }
	async function fetchSheet(range){ const url = `/api/values?range=${encodeURIComponent(range)}`; const res = await fetch(url, { cache: 'no-store' }); if(!res.ok){ const txt = await res.text(); throw new Error(`HTTP ${res.status}: ${txt}`); } const data = await res.json(); return data.values || []; }
	function updateDashboard(data){ if(!data) return; const isDisconnected = (data.vMeas === 0 && data.iMeas === 0); let socAvg = null; if(!isDisconnected && typeof data.socCc==='number' && typeof data.socEkf==='number'){ socAvg = (data.socCc + data.socEkf) / 2; } else if(!isDisconnected && typeof data.socCc==='number'){ socAvg = data.socCc; } else if(!isDisconnected && typeof data.socEkf==='number'){ socAvg = data.socEkf; } if(socAvg !== null && !isDisconnected){ socValEl && (socValEl.textContent = `${socAvg.toFixed(0)}%`); drawSocGauge(socGauge, socAvg, false); } else if(isDisconnected){ socValEl && (socValEl.textContent = 'Disconnected'); drawSocGauge(socGauge, 0, true); } if(typeof data.socCc==='number' && !isDisconnected){ socCcEl && (socCcEl.textContent = `${data.socCc.toFixed(0)}%`); } else if(isDisconnected){ socCcEl && (socCcEl.textContent = '--'); } if(typeof data.socEkf==='number' && !isDisconnected){ socEkfEl && (socEkfEl.textContent = `${data.socEkf.toFixed(0)}%`); } else if(isDisconnected){ socEkfEl && (socEkfEl.textContent = '--'); } if(typeof data.socAi==='number' && !isDisconnected){ socAiEl && (socAiEl.textContent = `${data.socAi.toFixed(0)}%`); } else if(isDisconnected){ socAiEl && (socAiEl.textContent = '--'); } const isIdle = (String(data.status||'').toLowerCase().includes('idle')); if(typeof data.vMeas==='number'){ const displayV = (isIdle && data.vMeas===0) ? undefined : data.vMeas; if(displayV!==undefined){ voltValEl && (voltValEl.textContent = displayV.toFixed(3)); history.voltage.push(displayV); if(history.voltage.length>historyLimit) history.voltage.shift(); } } if(typeof data.vModel==='number'){ voltModelValEl && (voltModelValEl.textContent = data.vModel.toFixed(3)); } if(typeof data.vRcEkf==='number'){ voltRcEkfEl && (voltRcEkfEl.textContent = data.vRcEkf.toFixed(3)); } if(typeof data.iMeas==='number'){ currValEl && (currValEl.textContent = data.iMeas.toFixed(3)); history.current.push(data.iMeas); if(history.current.length>historyLimit) history.current.shift(); } if(typeof data.temp==='number'){ tempValEl && (tempValEl.textContent = data.temp.toFixed(2)); history.temperature.push(data.temp); if(history.temperature.length>historyLimit) history.temperature.shift(); drawSparkline(tempSpark, history.temperature, '#f97316'); } if(isDisconnected){ stateValEl && (stateValEl.textContent = 'Battery Disconnected'); stateValEl && (stateValEl.className = 'state-idle'); } else if(typeof data.status==='string'){ stateValEl && (stateValEl.textContent = data.status || '--'); applyStateColor(data.status); } if(typeof data.timestamp==='string'){ tsValEl && (tsValEl.textContent = data.timestamp || '--'); } }
	async function refresh(){ try { setStatus('Fetching…'); const values = await fetchSheet(FIXED_RANGE); const newSum = checksum(values); if(newSum !== lastChecksum){ renderTable(values); lastChecksum = newSum; } const latest = parseLatest(values); updateDashboard(latest); const series = sliceLastNSeries(values, 10); drawVoltageChart(voltSpark, series.vMeas, series.vModel, series.vRcEkf, series.timestamps); drawCurrentChart(currSpark, series.current, series.timestamps); setLastUpdated(); setStatus('Live'); } catch(err){ console.error(err); setStatus(`Error: ${err.message || err}`, true); } }
	function startPolling(){ if(pollTimer){ clearInterval(pollTimer); } pollTimer = setInterval(() => refresh(), POLL_MS); }
	// Init
	setStatus('Initializing…');
	refresh();
	startPolling();
})();
